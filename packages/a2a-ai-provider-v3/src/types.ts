/**
 * A2A V3 Provider Types
 *
 * Type definitions that bridge A2A protocol structures with AI SDK's type system.
 *
 * ## Type Hierarchy
 *
 * The A2A protocol uses these content types:
 * - **Part**: The atomic content unit (TextPart, FilePart, DataPart)
 * - **Message**: A turn of communication containing Parts
 * - **Artifact**: A tangible output containing Parts
 * - **Task**: A stateful work unit with status and artifacts
 *
 * This module provides serializable versions of these types that extend
 * AI SDK's `JSONObject` for safe transport via `providerMetadata`.
 *
 * ## Why Serialized Types?
 *
 * AI SDK's `providerMetadata` must be JSON-serializable (`SharedV3ProviderMetadata`).
 * The A2A SDK types use `Record<string, unknown>` which isn't directly compatible.
 * These `A2aSerialized*` types ensure type-safe JSON transport while preserving
 * all A2A protocol information.
 *
 * @module
 */

import type { JSONObject, JSONValue, SharedV3ProviderMetadata } from "@ai-sdk/provider";
import type { IdGenerator } from "@ai-sdk/provider-utils";
import type {
  Message,
  Task,
  TaskArtifactUpdateEvent,
  TaskState,
  TaskStatusUpdateEvent,
} from "@drew-foxall/a2a-js-sdk";

/**
 * Union of all A2A streaming event types.
 *
 * When streaming responses from an A2A agent, the server sends these event types:
 * - `Task`: Complete task with status and artifacts (non-streaming or final event)
 * - `Message`: Direct message response (immediate responses)
 * - `TaskStatusUpdateEvent`: Status change notification (working → completed)
 * - `TaskArtifactUpdateEvent`: Artifact content chunk (streaming artifacts)
 *
 * @see https://a2a-protocol.org/latest/topics/streaming-asynchronous/
 */
export type A2AStreamEventData = Task | Message | TaskStatusUpdateEvent | TaskArtifactUpdateEvent;

/**
 * JSON-serializable file information.
 *
 * A2A FileParts can contain either inline bytes (base64) or a URI reference.
 * This interface ensures the file data is JSON-compatible for providerMetadata.
 *
 * @see https://a2a-protocol.org/latest/topics/key-concepts/#messages-and-parts
 */
export interface A2aSerializedFile extends JSONObject {
  /** MIME type (e.g., 'image/png', 'application/pdf') */
  mimeType?: string;
  /** Human-readable filename */
  name?: string;
  /** URI reference to the file (alternative to bytes) */
  uri?: string;
  /** Base64-encoded file content (alternative to uri) */
  bytes?: string;
}

/**
 * JSON-serializable A2A Part.
 *
 * Parts are the fundamental content containers in A2A. They appear in Messages
 * and Artifacts. This serialized version is safe for `providerMetadata`.
 *
 * ## Part Types
 *
 * - **TextPart** (`kind: "text"`): Plain text content
 * - **FilePart** (`kind: "file"`): Binary file (image, document, etc.)
 * - **DataPart** (`kind: "data"`): Structured JSON data for custom events
 *
 * ## Using DataParts for Custom Events
 *
 * DataParts enable rich agent-to-agent communication beyond text:
 *
 * ```typescript
 * // Send custom event via providerOptions
 * const result = await generateText({
 *   model: a2aV3('http://localhost:3001'),
 *   prompt: 'Process selection',
 *   providerOptions: {
 *     a2a: {
 *       customParts: [{
 *         kind: 'data',
 *         data: { eventType: 'user-selection', items: ['a', 'b'] }
 *       }]
 *     }
 *   }
 * });
 *
 * // Read custom events from response
 * const dataParts = result.providerMetadata?.a2a?.statusMessage?.parts
 *   .filter(p => p.kind === 'data');
 * ```
 *
 * @see https://a2a-protocol.org/latest/topics/key-concepts/#messages-and-parts
 */
export interface A2aSerializedPart extends JSONObject {
  /** Discriminator for part type */
  kind: "text" | "file" | "data";
  /** Text content (for kind: "text") */
  text?: string;
  /** Structured JSON data (for kind: "data") - use for custom events */
  data?: JSONObject;
  /** File information (for kind: "file") */
  file?: A2aSerializedFile;
  /** Part-level extension metadata */
  metadata?: JSONObject;
}

/**
 * JSON-serializable A2A status message.
 *
 * The status message represents the agent's current communication state.
 * It contains the agent's response parts and appears in `providerMetadata.a2a.statusMessage`.
 *
 * @see https://a2a-protocol.org/latest/topics/key-concepts/#messages-and-parts
 */
export interface A2aSerializedStatusMessage extends JSONObject {
  /** Unique identifier for this message */
  messageId: string;
  /** Who sent this message: "agent" or "user" */
  role: "agent" | "user";
  /** Content parts (text, files, data) */
  parts: A2aSerializedPart[];
  /** Message-level extension metadata */
  metadata?: JSONObject;
}

/**
 * JSON-serializable A2A artifact.
 *
 * Artifacts are tangible outputs generated by agents during task processing.
 * Unlike messages (which are conversational), artifacts are deliverables like
 * generated documents, images, or structured data.
 *
 * Access via `result.providerMetadata.a2a.artifacts`.
 *
 * @see https://a2a-protocol.org/latest/topics/key-concepts/#artifacts
 */
export interface A2aSerializedArtifact extends JSONObject {
  /** Unique identifier for this artifact */
  artifactId: string;
  /** Human-readable name */
  name?: string;
  /** Description of what this artifact contains */
  description?: string;
  /** Content parts (the actual artifact data) */
  parts: A2aSerializedPart[];
  /** Artifact-level extension metadata */
  metadata?: JSONObject;
}

/**
 * A2A-specific metadata exposed via `result.providerMetadata.a2a`.
 *
 * This is the primary interface for accessing A2A protocol information from
 * AI SDK responses. It exposes everything you need to:
 *
 * 1. **Detect interactive flows**: Check `inputRequired` for agents needing more input
 * 2. **Continue conversations**: Use `taskId` and `contextId` for follow-ups
 * 3. **Access rich content**: Get full Parts including custom DataParts
 * 4. **Retrieve artifacts**: Access generated documents, files, structured data
 * 5. **Read extensions**: Custom protocol metadata from agent implementations
 *
 * ## A2A Task States
 *
 * The `taskState` field reflects the A2A task lifecycle:
 * - `submitted`: Task received, not yet processing
 * - `working`: Agent is actively processing
 * - `completed`: Task finished successfully
 * - `input-required`: Agent needs more user input to proceed
 * - `auth-required`: Agent needs authentication
 * - `failed`: Task failed with error
 * - `canceled`: Task was canceled
 * - `rejected`: Agent rejected the request
 *
 * ## Example: Handling Input-Required Flow
 *
 * ```typescript
 * import { a2aV3 } from '@drew-foxall/a2a-ai-provider-v3';
 * import { generateText } from 'ai';
 *
 * const result = await generateText({
 *   model: a2aV3('http://localhost:3001'),
 *   prompt: 'Book a flight',
 * });
 *
 * const a2a = result.providerMetadata?.a2a;
 *
 * if (a2a?.inputRequired) {
 *   // Agent needs more info - show the question to user
 *   const question = a2a.statusMessage?.parts
 *     .filter(p => p.kind === 'text')
 *     .map(p => p.text)
 *     .join('');
 *
 *   console.log('Agent asks:', question);
 *
 *   // Send follow-up with the same taskId/contextId
 *   const followUp = await generateText({
 *     model: a2aV3('http://localhost:3001'),
 *     prompt: 'I want to go to Paris on Monday',
 *     providerOptions: {
 *       a2a: {
 *         taskId: a2a.taskId,      // Resume this task
 *         contextId: a2a.contextId, // Same conversation
 *       }
 *     }
 *   });
 * }
 *
 * // Access artifacts (generated files, documents)
 * for (const artifact of a2a?.artifacts ?? []) {
 *   console.log(`Artifact: ${artifact.name}`);
 *   for (const part of artifact.parts) {
 *     if (part.kind === 'file') {
 *       console.log(`  File: ${part.file?.name} (${part.file?.mimeType})`);
 *     }
 *   }
 * }
 * ```
 *
 * @see https://a2a-protocol.org/latest/topics/life-of-a-task/
 */
export interface A2aProviderMetadata extends JSONObject {
  /**
   * Task ID for continuing this task.
   *
   * Pass this to `providerOptions.a2a.taskId` to send follow-up messages
   * to an `input-required` task. The server routes your message to the
   * existing task instead of creating a new one.
   */
  taskId: string | null;

  /**
   * Context ID for conversation continuity.
   *
   * Pass this to `providerOptions.a2a.contextId` to continue a conversation.
   * All tasks in the same context share history and state.
   */
  contextId: string | null;

  /**
   * Current A2A task state.
   *
   * Maps to AI SDK finish reasons:
   * - `completed` → "stop"
   * - `input-required` → "stop" (check `inputRequired` flag)
   * - `failed` → "error"
   * - `working` → "unknown" (streaming in progress)
   */
  taskState: TaskState | null;

  /**
   * True when the agent needs more user input to proceed.
   *
   * This is a convenience flag equivalent to `taskState === "input-required"`.
   * When true, send a follow-up message with `taskId` and `contextId` to continue.
   */
  inputRequired: boolean;

  /**
   * True when the agent requires authentication to proceed.
   *
   * This is a convenience flag equivalent to `taskState === "auth-required"`.
   * When true, the client should authenticate and retry the request.
   * Check the agent's `AgentCard.securitySchemes` for supported auth methods.
   */
  authRequired: boolean;

  /**
   * The agent's status message with all content parts.
   *
   * Contains the full response including TextParts, FileParts, and DataParts.
   * DataParts are particularly useful for custom agent-to-agent events.
   */
  statusMessage: A2aSerializedStatusMessage | null;

  /**
   * Final authoritative text content from the "completed" state.
   *
   * When an A2A agent streams responses, it sends "working" state deltas followed
   * by a "completed" state with the full final text. Since AI SDK accumulates
   * text-deltas (and some agents send intermediate messages like "Processing..."),
   * this field contains the authoritative final text that should replace
   * the accumulated content.
   *
   * Client code can use this in `onFinish` to replace the message content:
   * ```typescript
   * onFinish: ({ message }) => {
   *   const finalText = message.providerMetadata?.a2a?.finalText;
   *   if (finalText) {
   *     // Replace message content with authoritative final text
   *     setMessages(msgs => msgs.map(m =>
   *       m.id === message.id ? { ...m, parts: [{ type: 'text', text: finalText }] } : m
   *     ));
   *   }
   * }
   * ```
   */
  finalText: string | null;

  /**
   * Artifacts generated by the agent.
   *
   * Artifacts are tangible outputs like documents, images, or structured data.
   * Each artifact has a unique `artifactId` and contains content parts.
   */
  artifacts: A2aSerializedArtifact[];

  /**
   * Task-level extension metadata from the agent.
   *
   * Custom protocol extensions can store data here. Check your agent's
   * documentation for available metadata fields.
   */
  metadata: JSONObject | null;
}

/**
 * Internal configuration for the A2A V3 model.
 *
 * Used by `A2aV3LanguageModel` constructor. Most users won't need this directly.
 */
export interface A2aV3ModelConfig {
  /** Provider identifier for logging and debugging */
  provider: string;
  /** Custom ID generator for A2A message IDs */
  generateId?: IdGenerator;
}

/**
 * A2A-specific options for AI SDK requests.
 *
 * Pass these via `providerOptions.a2a` in `generateText()` or `streamText()`:
 *
 * ```typescript
 * const result = await generateText({
 *   model: a2aV3('http://localhost:3001'),
 *   prompt: 'Continue the task',
 *   providerOptions: {
 *     a2a: {
 *       taskId: 'task_abc123',     // Resume existing task
 *       contextId: 'ctx_xyz789',   // Continue conversation
 *       customParts: [...],        // Additional data parts
 *       metadata: { ... },         // Message metadata
 *     }
 *   }
 * });
 * ```
 *
 * ## When to Use Each Option
 *
 * | Option | Use Case |
 * |--------|----------|
 * | `contextId` | Continue a conversation across multiple requests |
 * | `taskId` | Respond to an `input-required` task |
 * | `customParts` | Send structured data/events to the agent |
 * | `metadata` | Attach metadata to the message |
 * | `requestMetadata` | Attach metadata to the JSON-RPC request |
 */
export interface A2aProviderOptions {
  /**
   * Context ID for conversation continuity.
   *
   * Get this from a previous response's `providerMetadata.a2a.contextId`.
   * All messages with the same contextId share conversation history.
   */
  contextId?: string;

  /**
   * Task ID for resuming an existing task.
   *
   * Required when responding to `input-required` state. Get this from
   * the previous response's `providerMetadata.a2a.taskId`.
   */
  taskId?: string;

  /**
   * Custom parts to include in the outgoing message.
   *
   * Use DataParts to send structured events or data to the agent:
   *
   * ```typescript
   * customParts: [
   *   { kind: 'data', data: { eventType: 'selection', value: 'option-a' } },
   *   { kind: 'file', file: { uri: 'https://...', mimeType: 'image/png' } }
   * ]
   * ```
   */
  customParts?: A2aSerializedPart[];

  /**
   * Message-level metadata for protocol extensions.
   *
   * Attached to the A2A Message object. Check your agent's documentation
   * for supported metadata fields.
   */
  metadata?: Record<string, unknown>;

  /**
   * Request-level metadata for protocol extensions.
   *
   * Attached to the JSON-RPC request envelope. Used for request-scoped
   * configuration separate from message content.
   */
  requestMetadata?: Record<string, unknown>;

  /**
   * Controls whether `status-update` events in the "working" state stream their text
   * into the assistant message.
   *
   * When `false`, the provider will **not** emit text deltas for working status updates,
   * but will still emit the authoritative "completed" text when the task completes.
   *
   * This avoids UIs rendering multiple text parts (working + completed) and prevents
   * "double message" flicker during streaming.
   *
   * @default true
   */
  streamWorkingStatusText?: boolean;
}

// =============================================================================
// JSON Conversion Utilities
// =============================================================================

/**
 * Safely converts Record<string, unknown> to JSONObject.
 *
 * The A2A SDK uses Record<string, unknown> for metadata fields, but the AI SDK
 * requires JSONObject. This performs a runtime-safe conversion that preserves
 * JSON-compatible values and drops non-JSON values.
 *
 * @returns JSONObject if input contains only JSON-compatible values, undefined otherwise
 */
export function toJSONObject(value: Record<string, unknown> | undefined): JSONObject | undefined {
  if (value === undefined) return undefined;

  // The metadata from A2A should be JSON-compatible at runtime
  // We perform the cast after validating structure
  const result: JSONObject = {};
  for (const [key, val] of Object.entries(value)) {
    if (isJSONValue(val)) {
      result[key] = val;
    }
    // Non-JSON values are silently dropped
  }
  return result;
}

/**
 * Safely converts Record<string, unknown> | null to JSONObject | null
 */
export function toJSONObjectOrNull(
  value: Record<string, unknown> | null | undefined
): JSONObject | null {
  if (value === null || value === undefined) return null;
  return toJSONObject(value) ?? null;
}

/**
 * Type guard for JSONValue
 */
export function isJSONValue(value: unknown): value is JSONValue {
  if (value === null) return true;
  if (typeof value === "string") return true;
  if (typeof value === "number") return true;
  if (typeof value === "boolean") return true;
  if (Array.isArray(value)) return value.every(isJSONValue);
  if (typeof value === "object") {
    return Object.values(value).every((v) => v === undefined || isJSONValue(v));
  }
  return false;
}

// =============================================================================
// Type Guards
// =============================================================================

/**
 * Type guard for A2A provider options
 */
export function isA2aProviderOptions(value: unknown): value is A2aProviderOptions {
  if (!value || typeof value !== "object") return false;
  const obj = value as Record<string, unknown>;

  // All fields are optional, but if present must be correct types
  if ("contextId" in obj && typeof obj.contextId !== "string") return false;
  if ("taskId" in obj && typeof obj.taskId !== "string") return false;
  if ("customParts" in obj && !isSerializedPartArray(obj.customParts)) return false;
  if ("metadata" in obj && !isRecordStringUnknown(obj.metadata)) return false;
  if ("requestMetadata" in obj && !isRecordStringUnknown(obj.requestMetadata)) return false;
  if ("streamWorkingStatusText" in obj && typeof obj.streamWorkingStatusText !== "boolean") {
    return false;
  }

  return true;
}

/**
 * Type guard for A2aSerializedPart
 */
export function isSerializedPart(value: unknown): value is A2aSerializedPart {
  if (!value || typeof value !== "object") return false;
  const obj = value as Record<string, unknown>;
  return obj.kind === "text" || obj.kind === "file" || obj.kind === "data";
}

/**
 * Type guard for A2aSerializedPart array
 */
export function isSerializedPartArray(value: unknown): value is A2aSerializedPart[] {
  return Array.isArray(value) && value.every(isSerializedPart);
}

/**
 * Type guard for Record<string, unknown>
 */
export function isRecordStringUnknown(value: unknown): value is Record<string, unknown> {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}

/**
 * Type guard for string
 */
export function isString(value: unknown): value is string {
  return typeof value === "string";
}

/**
 * Type guard for Uint8Array
 */
export function isUint8Array(value: unknown): value is Uint8Array {
  return value instanceof Uint8Array;
}

/**
 * Extract A2A options from provider options with type safety
 */
export function getA2aOptions(
  providerOptions: Record<string, Record<string, unknown>> | undefined
): A2aProviderOptions | undefined {
  const a2a = providerOptions?.a2a;
  if (a2a && isA2aProviderOptions(a2a)) {
    return a2a;
  }
  return undefined;
}

// =============================================================================
// Factory Functions
// =============================================================================

/**
 * Empty metadata object for initialization
 */
export function createEmptyMetadata(): A2aProviderMetadata {
  return {
    taskId: null,
    contextId: null,
    taskState: null,
    inputRequired: false,
    authRequired: false,
    statusMessage: null,
    finalText: null,
    artifacts: [],
    metadata: null,
  };
}

/**
 * Wraps A2aProviderMetadata in SharedV3ProviderMetadata structure.
 *
 * Since A2aProviderMetadata extends JSONObject, and SharedV3ProviderMetadata
 * is Record<string, JSONObject>, this is type-safe without casting.
 */
export function wrapProviderMetadata(metadata: A2aProviderMetadata): SharedV3ProviderMetadata {
  return { a2a: metadata };
}

/**
 * Converts JSONObject back to Record<string, unknown> for A2A SDK compatibility.
 *
 * JSONObject is a subtype of Record<string, unknown>, so this conversion is
 * always safe. This helper exists for consistency with toJSONObject() and
 * to avoid scattered casts throughout the codebase.
 */
export function fromJSONObject(value: JSONObject): Record<string, unknown>;
export function fromJSONObject(value: JSONObject | undefined): Record<string, unknown> | undefined;
export function fromJSONObject(value: JSONObject | null): Record<string, unknown> | null;
export function fromJSONObject(
  value: JSONObject | undefined | null
): Record<string, unknown> | undefined | null {
  // JSONObject ({ [key: string]: JSONValue | undefined }) is assignable to
  // Record<string, unknown>, so no runtime conversion needed
  return value as Record<string, unknown> | undefined | null;
}
